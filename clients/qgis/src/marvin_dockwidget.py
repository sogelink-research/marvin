# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MarvinDockWidget
                                 A QGIS plugin
 Marvin QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-24
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Sogelink
        email                : support@sogelink.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import configparser
import requests
import json

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtWidgets import QMessageBox
from qgis.core import QgsGeometry, QgsVectorLayer, QgsProject, QgsFeature, QgsLineSymbol,QgsSingleSymbolRenderer,QgsMarkerSymbol
from qgis.core import QgsProject, QgsCoordinateTransform, QgsCoordinateReferenceSystem
from qgis.utils import iface
from PyQt5.QtCore import QUrl, QEventLoop
from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkRequest
from qgis.core import QgsWkbTypes
from PyQt5.QtCore import QVariant

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'marvin_dockwidget_base.ui'))


class MarvinDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MarvinDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.pushButton.clicked.connect(self.on_button_click)
        self.plainTextEdit.textChanged.connect(self.on_text_change)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def on_text_change(self):
        q = self.plainTextEdit.toPlainText()
        if q.endswith("\n"):
            self.handlePrompt(q)

    def on_button_click(self):
        q = self.plainTextEdit.toPlainText()
        self.handlePrompt(q)

    def handlePrompt(self,q):
        plugin_folder = self.get_plugin_folder()
        server_url = self.read_server_name(plugin_folder + os.sep + "config.ini")

        json_data = {
            "question": q,
            "geom": "",
            "userLocation": "",
            "debug": False
        }
        print(json_data)
        # response = self.post_to_server(server_url,json_data)
        response = self.fetch_data_qt(server_url,json_data)

        print(response)

        error = response.get('error', '')

        if error == 'NO_GEO_FOCUS_FOUND':
            QMessageBox.information(self.pushButton, "Error", "error: No Geofocus found")
        # elif error == "INVALID_SQL_QUERY" or "NO_SQL_RESULT_RETURNED":
                                
        else:
            data = response.get('data')
            if data is not None and len(data) > 0 and data[0] is not None:
                wkts = []

                for d in data:
                    if 'geom' in d:
                        wkts.append(d['geom'])

                if len(wkts)> 0:
                    self.draw_wkt(wkts)
                else:
                    QMessageBox.information(self.pushButton, "Error", "No geometry found in data")                                
            else:
                QMessageBox.information(self.pushButton, "Error", "Data not ok")



    def read_server_name(self, config_path="config.ini"):
        """Reads the server name from a config.ini file."""
        if not os.path.exists(config_path):
            QMessageBox.information(self.pushButton, "Error", "error: config file " + config_path + " does not exist.")
            return None
        config = configparser.ConfigParser()
        config.read(config_path)

        # Check if the section and key exist
        if "Server" in config and "name" in config["Server"]:
            return config["Server"]["name"]
        else:
            print("Error: 'Server' section or 'name' key is missing in config.ini")
            return None

    def get_plugin_folder(self):
        plugin_folder = os.path.dirname(os.path.abspath(__file__))
        return plugin_folder
    
    def fetch_data_qt(self, server_url, json_data):
        manager = QNetworkAccessManager()
        loop = QEventLoop()  # Zorgt voor synchroon wachten zonder UI te blokkeren

        request = QNetworkRequest(QUrl(server_url))
        request.setHeader(QNetworkRequest.ContentTypeHeader, "application/json")

        reply = manager.post(request, json.dumps(json_data).encode('utf-8'))
        reply.finished.connect(loop.quit)  # Stop de event loop als het verzoek klaar is
        loop.exec_()  # Start de event loop

        return json.loads(reply.readAll().data().decode())  # JSON-antwoord als string

    def draw_wkt(self, wkts):
        geom = QgsGeometry.fromWkt(wkts[0])
        if geom.type() == QgsWkbTypes.PolygonGeometry:
            layer = QgsVectorLayer("Polygon?crs=EPSG:4326", "WKT Polygoon", "memory")
        elif geom.type() == QgsWkbTypes.LineGeometry:
            layer = QgsVectorLayer("LineString?crs=EPSG:4326", "WKT Lijn", "memory")
            line_symbol = QgsLineSymbol.createSimple({'color': 'red', 'width': '2'})
            renderer = QgsSingleSymbolRenderer(line_symbol)
            layer.setRenderer(renderer)
            print("line symbol aangepast")
        elif geom.type() == QgsWkbTypes.PointGeometry:
            layer = QgsVectorLayer("Point?crs=EPSG:4326", "WKT Punt", "memory")
            point_symbol = QgsMarkerSymbol.createSimple({'color': 'blue', 'size': '3'})
            renderer = QgsSingleSymbolRenderer(point_symbol)
            layer.setRenderer(renderer)
            print("point symbol aangepast")            
        else:
            raise ValueError("Unsupported geometry type")

        layer_provider = layer.dataProvider()
        
        for wkt in wkts:
            geometry = QgsGeometry.fromWkt(wkt)

            if geometry.isEmpty():
                print("Invalid geometry!")
                return
            
            feature = QgsFeature()
            # todo add atttibutes

            feature.setGeometry(geometry)
            layer_provider.addFeature(feature)


        layer.updateExtents()

        extent = layer.extent() 
        
        QgsProject.instance().addMapLayer(layer)

        canvas = iface.mapCanvas()

        crs_source = QgsCoordinateReferenceSystem("EPSG:4326")
        crs_project = canvas.mapSettings().destinationCrs()
    
        transform = QgsCoordinateTransform(crs_source, crs_project, QgsProject.instance())
        transformed_extent = transform.transformBoundingBox(extent)

        canvas.setExtent(transformed_extent)
        canvas.refresh()
        
        print("klaar")
