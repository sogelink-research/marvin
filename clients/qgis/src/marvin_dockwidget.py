# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MarvinDockWidget
                                 A QGIS plugin
 Marvin QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-24
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Sogelink
        email                : support@sogelink.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import configparser
import requests
import json

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtWidgets import QMessageBox
from qgis.core import QgsGeometry, QgsVectorLayer, QgsProject, QgsFeature, QgsField
from qgis.core import QgsProject, QgsCoordinateTransform, QgsCoordinateReferenceSystem
from qgis.utils import iface
from PyQt5.QtCore import QUrl, QEventLoop
from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkRequest

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'marvin_dockwidget_base.ui'))


class MarvinDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MarvinDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.pushButton.clicked.connect(self.on_button_click)


    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()


    def on_button_click(self):
            plugin_folder = self.get_plugin_folder()
            server_url = self.read_server_name(plugin_folder + os.sep + "config.ini")

            # Controleer of de QPlainTextEdit leeg is
            if not self.plainTextEdit.toPlainText():
                QMessageBox.information(self.pushButton, "Info", "Ask question first")
            else:
                q = self.plainTextEdit.toPlainText()
                json_data = {
                    "question": q,
                    "geom": "",
                    "userLocation": "",
                    "debug": False
                }
                print(json_data)
                # response = self.post_to_server(server_url,json_data)
                response = self.fetch_data_qt(server_url,json_data)

                print(response)

                error = response.get('error', '')

                if error == 'NO_GEO_FOCUS_FOUND':
                    QMessageBox.information(self.pushButton, "Error", "error: No Geofocus found")
                elif error == "INVALID_SQL_QUERY" or "NO_SQL_RESULT_RETURNED":
                    print(error)
                    focus = response.get('focus')
                    locations = focus.get('locations')
                    first_loc = locations[0]
                    name = first_loc.get('name')
                    print(name)
                    wkt = first_loc.get('geometry')
                    print("wkt" + wkt)
                    self.draw_wkt(wkt)
                                        
                else:
                    data = response.get('data')
                    geometry = data[0]['geom']
                    print("geometry: " + geometry)
                    self.draw_wkt(wkt)

    def read_server_name(self, config_path="config.ini"):
        """Reads the server name from a config.ini file."""
        if not os.path.exists(config_path):
            QMessageBox.information(self.pushButton, "Error", "error: config file " + config_path + " does not exist.")
            return None
        config = configparser.ConfigParser()
        config.read(config_path)

        # Check if the section and key exist
        if "Server" in config and "name" in config["Server"]:
            return config["Server"]["name"]
        else:
            print("Error: 'Server' section or 'name' key is missing in config.ini")
            return None

    def get_plugin_folder(self):
        plugin_folder = os.path.dirname(os.path.abspath(__file__))
        return plugin_folder
    
    def fetch_data_qt(self, server_url, json_data):
        manager = QNetworkAccessManager()
        loop = QEventLoop()  # Zorgt voor synchroon wachten zonder UI te blokkeren

        request = QNetworkRequest(QUrl(server_url))
        request.setHeader(QNetworkRequest.ContentTypeHeader, "application/json")

        reply = manager.post(request, json.dumps(json_data).encode('utf-8'))
        reply.finished.connect(loop.quit)  # Stop de event loop als het verzoek klaar is
        loop.exec_()  # Start de event loop

        return json.loads(reply.readAll().data().decode())  # JSON-antwoord als string

    def draw_wkt(self, wkt):
        geometry = QgsGeometry.fromWkt(wkt)
        print("Is geldige geometrie:", geometry.isGeosValid())
        print("Geometrie type:", geometry.type())  # 0 = punt, 1 = lijn, 2 = polygoon
        print("WKT-representatie:", geometry.asWkt())
        print("Bounding box:", geometry.boundingBox().toString())

        extent = geometry.boundingBox()

        if geometry.isEmpty():
            print("Invalid geometry!")
            return
        
        layer = QgsVectorLayer("Polygon?crs=EPSG:4326", "WKT Polygoon", "memory")

        layer_provider = layer.dataProvider()
        # layer_provider.addAttributes([QgsField("id", QVariant.Int)])
        # layer.updateFields()

        # Maak een feature en voeg de geometrie toe
        feature = QgsFeature()
        feature.setGeometry(geometry)
        feature.setAttributes([1])  # Stel ID in

        layer_provider.addFeature(feature)
        layer.updateExtents()

        QgsProject.instance().addMapLayer(layer)

        canvas = iface.mapCanvas()

        crs_source = QgsCoordinateReferenceSystem("EPSG:4326")
        crs_project = canvas.mapSettings().destinationCrs()
    
        transform = QgsCoordinateTransform(crs_source, crs_project, QgsProject.instance())
        transformed_extent = transform.transformBoundingBox(extent)

        canvas.setExtent(transformed_extent)
        canvas.refresh()
        
        print("klaar")
